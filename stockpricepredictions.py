# -*- coding: utf-8 -*-
"""StockPricePredictions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10Fa1X_avQyVNmKBSu_9ox8GSVQPYwp0T
"""

import tensorflow as tf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from google.colab import files
files.upload()

"""# New Section"""

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d medharawat/google-stock-price

!unzip /content/google-stock-price.zip

dataframe = pd.read_csv("/content/Google_Stock_Price_Train.csv")

dataframe.head()

dataframe.info()

dataframe.isna().value_counts()

dataframe['Close']

open_list = dataframe.iloc[:, 1].values
open_list = np.reshape(open_list, (open_list.shape[0], 1))

closed_list = dataframe.iloc[:, 4].values
closed_list = np.array([float(i.replace(",","")) for i in closed_list])
closed_list = np.reshape(closed_list, (closed_list.shape[0], 1))

print(open_list.shape, closed_list.shape)

plt.figure(figsize=(10, 6))
plt.plot(open_list)
plt.grid()
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(closed_list)
plt.grid()
plt.show()

from sklearn.preprocessing import MinMaxScaler

sc = MinMaxScaler()
open_scaled = sc.fit_transform(open_list)

X_train = []
y_train = []
for i in range(60, len(open_scaled)):
  X_train.append(open_scaled[i-60:i, 0])
  y_train.append(open_scaled[i, 0])
X_train, y_train = np.array(X_train), np.array(y_train)

X_train[0]

y_train[0]

X_train[1]

y_train[1]

X_train.shape

X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

X_train[0]

X_train.shape

model1 = tf.keras.models.Sequential([
      tf.keras.layers.LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.LSTM(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.LSTM(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.LSTM(50),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(1)
])

model1.compile(optimizer='adam', loss='mse')
history = model1.fit(X_train, y_train, epochs=100, batch_size=32)

print("Mean loss of LSTM", np.mean(history.history['loss']))

pd.DataFrame(history.history).plot()

forecast = []
results = []
for time in range(len(open_scaled) - 60):
  forecast.append(model1.predict(open_scaled[time:time + 60][np.newaxis]))

res = np.zeros(len(open_scaled))
results = np.array(forecast)[:, 0, 0]
for i in range(len(res)):
  if i<60:
    pass
  elif i>=60:
    res[i] = results[i-60]
     
plt.figure(figsize=(10, 6))
plt.plot(open_scaled)
plt.plot(res)
plt.grid()

model2 = tf.keras.models.Sequential([
      tf.keras.layers.GRU(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.GRU(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.GRU(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.GRU(50),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(1)
])

model2.compile(optimizer='adam', loss='mse')
history = model2.fit(X_train, y_train, epochs=100, batch_size=32)

print("Mean loss of GRU", np.mean(history.history['loss']))

forecast = []
results = []
for time in range(len(open_scaled) - 60):
  forecast.append(model2.predict(open_scaled[time:time + 60][np.newaxis]))

results = np.array(forecast)[:, 0, 0]
res = np.zeros(len(open_scaled))

for i in range(len(res)):
  if i<60:
    pass
  elif i>=60:
    res[i] = results[i-60]

plt.figure(figsize=(10, 6))
plt.plot(open_scaled)
plt.plot(res)
plt.grid()

model3 = tf.keras.models.Sequential([
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1))),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50, return_sequences=True)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50, return_sequences=True)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(1)
])

model3.compile(optimizer='adam', loss='mse')
history = model3.fit(X_train, y_train, epochs=100, batch_size=32)

forecast = []
results = []
for time in range(len(open_scaled) - 60):
  forecast.append(model3.predict(open_scaled[time:time + 60][np.newaxis]))

results = np.array(forecast)[:, 0, 0]
res = np.zeros(len(open_scaled))

for i in range(len(res)):
  if i<60:
    pass
  elif i>=60:
    res[i] = results[i-60]

plt.figure(figsize=(10, 6))
plt.plot(open_scaled)
plt.plot(res)
plt.grid()

print("Mean loss of LSTM with Bidirectional", np.mean(history.history['loss']))

dataframe_test = pd.read_csv("/content/Google_Stock_Price_Test.csv")

dataframe_total = pd.concat((dataframe['Open'], dataframe_test['Open']), axis=0)

inputs = dataframe_total[len(dataframe_total)-len(dataframe_test)-60:].values

inputs = inputs.reshape(-1, 1)

inputs = sc.transform(inputs)

X_test = []
for i in range(60, 80):
  X_test.append(inputs[i-60:i, 0])
X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

predicted_stock_price = model3.predict(X_test)

predicted_stock_price = sc.inverse_transform(predicted_stock_price)

real_stock_price = dataframe_test.iloc[:, 1:2].values

plt.plot(real_stock_price, color = 'red', label = 'Real Google Stock Price')
plt.plot(predicted_stock_price, color = 'blue', label = 'Predicted Google Stock Price')
plt.title('Google Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Google Stock Price')
plt.legend()
plt.show()

from sklearn.preprocessing import MinMaxScaler

sc = MinMaxScaler()
closed_scaled = sc.fit_transform(closed_list)

X_train = []
y_train = []
for i in range(60, len(closed_scaled)):
  X_train.append(closed_scaled[i-60:i, 0])
  y_train.append(closed_scaled[i, 0])
X_train, y_train = np.array(X_train), np.array(y_train)

X_train[0]

y_train[0]

X_train[1]

X_train.shape

X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

X_train[0]

X_train.shape

model4 = tf.keras.models.Sequential([
      tf.keras.layers.LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.LSTM(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.LSTM(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.LSTM(50),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(1)
])

model4.compile(optimizer='adam', loss='mse')
history = model4.fit(X_train, y_train, epochs=100, batch_size=32)

print("Mean loss of LSTM", np.mean(history.history['loss']))

pd.DataFrame(history.history).plot()

forecast = []
results = []
for time in range(len(closed_scaled) - 60):
  forecast.append(model4.predict(closed_scaled[time:time + 60][np.newaxis]))

res = np.zeros(len(closed_scaled))
results = np.array(forecast)[:, 0, 0]
for i in range(len(res)):
  if i<60:
    pass
  elif i>=60:
    res[i] = results[i-60]
     
plt.figure(figsize=(10, 6))
plt.plot(closed_scaled)
plt.plot(res)
plt.grid()

model5 = tf.keras.models.Sequential([
      tf.keras.layers.GRU(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.GRU(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.GRU(50, return_sequences=True),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.GRU(50),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(1)
])

model5.compile(optimizer='adam', loss='mse')
history = model5.fit(X_train, y_train, epochs=100, batch_size=32)

print("Mean loss of GRU", np.mean(history.history['loss']))

pd.DataFrame(history.history).plot()

forecast = []
results = []
for time in range(len(closed_scaled) - 60):
  forecast.append(model5.predict(closed_scaled[time:time + 60][np.newaxis]))

res = np.zeros(len(closed_scaled))
results = np.array(forecast)[:, 0, 0]
for i in range(len(res)):
  if i<60:
    pass
  elif i>=60:
    res[i] = results[i-60]
     
plt.figure(figsize=(10, 6))
plt.plot(closed_scaled)
plt.plot(res)
plt.grid()

model6 = tf.keras.models.Sequential([
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1))),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50, return_sequences=True)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50, return_sequences=True)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(50)),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(1)
])

model6.compile(optimizer='adam', loss='mse')
history = model6.fit(X_train, y_train, epochs=100, batch_size=32)

print("Mean loss of Bi-directional LSTM", np.mean(history.history['loss']))

pd.DataFrame(history.history).plot()

forecast = []
results = []
for time in range(len(closed_scaled) - 60):
  forecast.append(model.predict(closed_scaled[time:time + 60][np.newaxis]))

res = np.zeros(len(closed_scaled))
results = np.array(forecast)[:, 0, 0]
for i in range(len(res)):
  if i<60:
    pass
  elif i>=60:
    res[i] = results[i-60]
     
plt.figure(figsize=(10, 6))
plt.plot(closed_scaled)
plt.plot(res)
plt.grid()

dataframe_test = pd.read_csv("/content/Google_Stock_Price_Test.csv")

dataframe_total = pd.concat((dataframe['Close'], dataframe_test['Close']), axis=0)

inputs = dataframe_total[len(dataframe_total)-len(dataframe_test)-60:].values

inputs = inputs.reshape(-1, 1)

inputs = sc.transform(inputs)

X_test = []
for i in range(60, 80):
  X_test.append(inputs[i-60:i, 0])
X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

predicted_stock_price = model6.predict(X_test)

predicted_stock_price = sc.inverse_transform(predicted_stock_price)

real_stock_price = dataframe_test.iloc[:, 4:5].values

plt.plot(real_stock_price, color = 'red', label = 'Real Google Stock Price')
plt.plot(predicted_stock_price, color = 'blue', label = 'Predicted Google Stock Price')
plt.title('Google Stock Price Prediction')
plt.xlabel('Time')
plt.ylabel('Google Stock Price')
plt.legend()
plt.show()